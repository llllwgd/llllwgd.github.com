{"meta":{"title":"llllwgd","subtitle":"大闹一场,悄然离去","description":"","author":"lllwgd","url":"https://llllwgd.github.io"},"pages":[{"title":"categories","date":"2020-07-11T17:20:15.000Z","updated":"2020-07-11T17:20:15.256Z","comments":true,"path":"categories/index.html","permalink":"https://llllwgd.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"中文乱码","slug":"中文乱码","date":"2020-10-09T05:56:11.581Z","updated":"2020-10-09T05:59:24.429Z","comments":true,"path":"2020/10/09/中文乱码/","link":"","permalink":"https://llllwgd.github.io/2020/10/09/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"拦截器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.doubao.pip.core.engine.config;import io.micrometer.core.lang.NonNull;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.core.Ordered;import org.springframework.web.filter.CharacterEncodingFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.Charset;/** * Description: 字符集拦截器 * * @author : llllwgd * Date: 2020-09-04 16:22 */public class MultiCharacterEncodingFilter extends CharacterEncodingFilter implements Ordered &#123; private final int order = Integer.MIN_VALUE; private static final Logger log = LoggerFactory.getLogger(MultiCharacterEncodingFilter.class); public static final String CUSTOM_ENCODE = \"custom_encode\"; @Override protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response, @NonNull FilterChain filterChain) throws ServletException, IOException &#123; try &#123; String path = request.getRequestURI(); if (isMultipartContent(request)) &#123; log.info(\"文件上传,不使用拦截器:path:&#123;&#125;\",path); &#125; if (!isMultipartContent(request)) &#123; String encode; if (StringUtils.isNotBlank(request.getCharacterEncoding())) &#123; encode = request.getCharacterEncoding(); &#125; else if (StringUtils.isNotBlank(request.getParameter(CUSTOM_ENCODE))) &#123; encode = request.getParameter(CUSTOM_ENCODE); &#125; else &#123; encode = Charset.defaultCharset().name(); &#125; log.info(\"路径:&#123;&#125;,使用字符集:&#123;&#125;\", path, encode); if (isForceRequestEncoding()) &#123; request.setCharacterEncoding(encode); &#125; filterChain.doFilter(request, response); &#125;else &#123; super.doFilterInternal(request, response, filterChain); &#125; &#125; catch (Exception e) &#123; log.error(\"use default encode:&#123;&#125;,path:&#123;&#125;,errMsg:&#123;&#125;\", Charset.defaultCharset().name(), request.getRequestURI(), e.getMessage()); super.doFilterInternal(request, response, filterChain); &#125; &#125; @Override public int getOrder() &#123; return order; &#125; public static boolean isMultipartContent(HttpServletRequest request) &#123; if (!\"post\".equals(request.getMethod().toLowerCase())) &#123; return false; &#125; String contentType = request.getContentType(); //获取Content-Type if ((contentType != null) &amp;&amp; (contentType.toLowerCase().startsWith(\"multipart/\"))) &#123; return true; &#125; else &#123; return false; &#125; &#125;&#125; 123456789101112131415161718192021222324package com.doubao.pip.core.engine.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Description: * * @author : llllwgd * Date: 2020-09-07 14:41 */@Configurationpublic class EncodeConfig &#123; @Bean() public MultiCharacterEncodingFilter multiCharacterEncodingFilter()&#123; MultiCharacterEncodingFilter encodingFilter = new MultiCharacterEncodingFilter(); encodingFilter.setEncoding(\"UTF-8\"); encodingFilter.setForceRequestEncoding(true); encodingFilter.setForceResponseEncoding(false); return encodingFilter; &#125;&#125;","categories":[{"name":"常见问题","slug":"常见问题","permalink":"https://llllwgd.github.io/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://llllwgd.github.io/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"}],"keywords":[{"name":"常见问题","slug":"常见问题","permalink":"https://llllwgd.github.io/categories/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"}]},{"title":"多线程","slug":"multithreading","date":"2020-09-30T02:38:01.558Z","updated":"2020-09-30T03:09:48.131Z","comments":true,"path":"2020/09/30/multithreading/","link":"","permalink":"https://llllwgd.github.io/2020/09/30/multithreading/","excerpt":"","text":"多线程线程的状态 NEW has not yet started RUNNABLE executing in java virtual machine but may be waiting for other resource from operating system BLOCKED waiting for a monitor lock to enter a synchronized block/method WAITING waiting for another thread perform a particular action TIMED_WAITING waiting for another thread perform a particular action TERMINATED thread has completed execution","categories":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://llllwgd.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}]},{"title":"mybatis","slug":"mybaits-study","date":"2020-07-12T03:05:56.923Z","updated":"2020-07-12T03:06:39.039Z","comments":true,"path":"2020/07/12/mybaits-study/","link":"","permalink":"https://llllwgd.github.io/2020/07/12/mybaits-study/","excerpt":"","text":"mybatis框架学习demopom.xml12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; mybatis-config.xml1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"LOG4J\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"com.llllwgd.mybatis.bean\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"UNPOOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?useSSL=false\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; log4j.properties12345678#全局配置log4j.rootLogger=ERROR, stdout#MyBatis日志配置log4j.logger.com.llllwgd.mybatis.mapper=DEBUG#控制台输出配置log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n 实体12345678910111213141516171819public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125;&#125; mapper1234567891011public interface UserMapper &#123; /** * 获取用户 * * @param name * @return */ User getUser(String name);&#125; mapper.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.llllwgd.mybatis.mapper.UserMapper\"&gt; &lt;select id=\"getUser\" resultType=\"User\"&gt; select `name` from user where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.llllwgd.mybatis;import com.llllwgd.mybatis.bean.User;import com.llllwgd.mybatis.mapper.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.BeforeClass;import org.junit.Test;import java.io.IOException;import java.io.Reader;import java.util.Map;/** * Created with IntelliJ IDEA. * Description: * * @author : wangguodong * Date: 2020-07-04 * Time: 16:15 */public class UserTest &#123; private static SqlSessionFactory sqlSessionFactory; @BeforeClass public static void init() &#123; try &#123; Reader reader = Resources.getResourceAsReader(\"mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); &#125; catch (IOException ignore) &#123; ignore.printStackTrace(); &#125; &#125; public SqlSession getSqlSession() &#123; return sqlSessionFactory.openSession(); &#125; @Test public void userTest() &#123; SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User tianshouzhi = mapper.getUser(\"tianshouzhi\"); System.out.println(tianshouzhi); &#125;&#125; 源码分析初始化配置123public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null);&#125; 123456789101112131415public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125;&#125; 12345678public Configuration parse() &#123; if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true; parseConfiguration(parser.evalNode(\"/configuration\")); return configuration;&#125; 12345678910111213141516171819202122private void parseConfiguration(XNode root) &#123; try &#123; //issue #117 read properties first propertiesElement(root.evalNode(\"properties\")); Properties settings = settingsAsProperties(root.evalNode(\"settings\")); loadCustomVfs(settings); loadCustomLogImpl(settings); typeAliasesElement(root.evalNode(\"typeAliases\")); pluginElement(root.evalNode(\"plugins\")); objectFactoryElement(root.evalNode(\"objectFactory\")); objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); reflectorFactoryElement(root.evalNode(\"reflectorFactory\")); settingsElement(settings); // read it after objectFactory and objectWrapperFactory issue #631 environmentsElement(root.evalNode(\"environments\")); databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); typeHandlerElement(root.evalNode(\"typeHandlers\")); mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125;&#125; 初始化环境(事务工厂和数据源)123456789101112131415161718192021private void environmentsElement(XNode context) throws Exception &#123; if (context != null) &#123; if (environment == null) &#123; environment = context.getStringAttribute(\"default\"); &#125; for (XNode child : context.getChildren()) &#123; String id = child.getStringAttribute(\"id\"); if (isSpecifiedEnvironment(id)) &#123; //创建事务工厂 TransactionFactory txFactory = transactionManagerElement(child.evalNode(\"transactionManager\")); //创建数据源工厂 DataSourceFactory dsFactory = dataSourceElement(child.evalNode(\"dataSource\")); DataSource dataSource = dsFactory.getDataSource(); Environment.Builder environmentBuilder = new Environment.Builder(id) .transactionFactory(txFactory) .dataSource(dataSource); configuration.setEnvironment(environmentBuilder.build()); &#125; &#125; &#125;&#125; 初始化事物工厂12345678910private TransactionFactory transactionManagerElement(XNode context) throws Exception &#123; if (context != null) &#123; String type = context.getStringAttribute(\"type\"); Properties props = context.getChildrenAsProperties(); TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance(); factory.setProperties(props); return factory; &#125; throw new BuilderException(\"Environment declaration requires a TransactionFactory.\");&#125; 初始化数据源工厂1234567891011private DataSourceFactory dataSourceElement(XNode context) throws Exception &#123; if (context != null) &#123; String type = context.getStringAttribute(\"type\"); Properties props = context.getChildrenAsProperties(); //org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory DataSourceFactory factory = (DataSourceFactory) resolveClass(type).getDeclaredConstructor().newInstance(); factory.setProperties(props); return factory; &#125; throw new BuilderException(\"Environment declaration requires a DataSourceFactory.\");&#125; 设置数据源123456789101112131415161718192021@Overridepublic void setProperties(Properties properties) &#123; Properties driverProperties = new Properties(); MetaObject metaDataSource = SystemMetaObject.forObject(dataSource); for (Object key : properties.keySet()) &#123; String propertyName = (String) key; if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123; String value = properties.getProperty(propertyName); driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value); &#125; else if (metaDataSource.hasSetter(propertyName)) &#123; String value = (String) properties.get(propertyName); Object convertedValue = convertValue(metaDataSource, propertyName, value); metaDataSource.setValue(propertyName, convertedValue); &#125; else &#123; throw new DataSourceException(\"Unknown DataSource property: \" + propertyName); &#125; &#125; if (driverProperties.size() &gt; 0) &#123; metaDataSource.setValue(\"driverProperties\", driverProperties); &#125;&#125; 初始化mapper123456789101112131415161718192021222324252627282930private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if (\"package\".equals(child.getName())) &#123; String mapperPackage = child.getStringAttribute(\"name\"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute(\"resource\"); String url = child.getStringAttribute(\"url\"); String mapperClass = child.getStringAttribute(\"class\"); if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\"); &#125; &#125; &#125; &#125;&#125; 解析mapper1234567891011public void parse() &#123; if (!configuration.isResourceLoaded(resource)) &#123; configurationElement(parser.evalNode(\"/mapper\")); configuration.addLoadedResource(resource); bindMapperForNamespace(); &#125; parsePendingResultMaps(); parsePendingCacheRefs(); parsePendingStatements();&#125; 获取sqlSession1234@Overridepublic SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);&#125; 123456789101112131415private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 获取mapper1234@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; return configuration.getMapper(type, this);&#125; 123public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; 1234567891011public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125;&#125; 1234public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy);&#125; 123456789101112@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else &#123; return cachedInvoker(method).invoke(proxy, method, args, sqlSession); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125;&#125; 123456789101112@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, args); &#125; else &#123; return cachedInvoker(method).invoke(proxy, method, args, sqlSession); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125;&#125; 1234@Overridepublic Object invoke(Object proxy, Method method, Object[] args, SqlSession sqlSession) throws Throwable &#123; return mapperMethod.execute(sqlSession, args);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; switch (command.getType()) &#123; case INSERT: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); break; &#125; case UPDATE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); break; &#125; case DELETE: &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); break; &#125; case SELECT: if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; result = executeForMap(sqlSession, args); &#125; else if (method.returnsCursor()) &#123; result = executeForCursor(sqlSession, args); &#125; else &#123; Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); if (method.returnsOptional() &amp;&amp; (result == null || !method.getReturnType().equals(result.getClass()))) &#123; result = Optional.ofNullable(result); &#125; &#125; break; case FLUSH: result = sqlSession.flushStatements(); break; default: throw new BindingException(\"Unknown execution method for: \" + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(\"Mapper method '\" + command.getName() + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\"); &#125; return result;&#125;","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://llllwgd.github.io/categories/mybatis/"}],"tags":[{"name":"mybaits","slug":"mybaits","permalink":"https://llllwgd.github.io/tags/mybaits/"}],"keywords":[{"name":"mybatis","slug":"mybatis","permalink":"https://llllwgd.github.io/categories/mybatis/"}]},{"title":"spring-mybatis","slug":"spirng-mybatis","date":"2020-07-11T07:02:21.151Z","updated":"2020-07-12T03:04:31.660Z","comments":true,"path":"2020/07/11/spirng-mybatis/","link":"","permalink":"https://llllwgd.github.io/2020/07/11/spirng-mybatis/","excerpt":"","text":"spirng-mybatisdemopom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.llllwgd.database&lt;/groupId&gt; &lt;artifactId&gt;spring-mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.properties12345spring.application.name=spring-mybatisdatasource.driver-class-name=com.mysql.cj.jdbc.Driverdatasource.url=jdbc:mysql://localhost:3306/test?useSSL=falsedatasource.username=rootdatasource.password=root main.java123456789@SpringBootApplication@MapperScan(\"com.llllwgd.database.springmybatis.dao\")public class SpringMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringMybatisApplication.class, args); &#125;&#125; config.java12345678910111213141516171819202122232425262728293031@Configurationpublic class DataSourceConfig &#123; @Value(\"$&#123;datasource.driver-class-name&#125;\") private String driver; @Value(\"$&#123;datasource.url&#125;\") private String url; @Value(\"$&#123;datasource.username&#125;\") private String username; @Value(\"$&#123;datasource.password&#125;\") private String password; @Bean public DataSource getDataSource() &#123; return new UnpooledDataSource(driver, url, username, password); &#125; @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource(dataSource); ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver(); Resource[] resources = resourceResolver.getResources(\"classpath*:mapper/*.xml\"); factoryBean.setMapperLocations(resources); return factoryBean.getObject(); &#125;&#125; 源码分析SqlSessionFactoryBean实现的接口FactoryBean1234567891011121314public interface FactoryBean&lt;T&gt; &#123; @Nullable T getObject() throws Exception; Class&lt;?&gt; getObjectType(); default boolean isSingleton() &#123; return true; &#125;&#125; 12345678@Overridepublic SqlSessionFactory getObject() throws Exception &#123; if (this.sqlSessionFactory == null) &#123; afterPropertiesSet(); &#125; return this.sqlSessionFactory;&#125; 123456789@Overridepublic void afterPropertiesSet() throws Exception &#123; notNull(dataSource, \"Property 'dataSource' is required\"); notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\"); state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null), \"Property 'configuration' and 'configLocation' can not specified with together\"); this.sqlSessionFactory = buildSqlSessionFactory();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113protected SqlSessionFactory buildSqlSessionFactory() throws IOException &#123; final Configuration targetConfiguration; XMLConfigBuilder xmlConfigBuilder = null; if (this.configuration != null) &#123; targetConfiguration = this.configuration; if (targetConfiguration.getVariables() == null) &#123; targetConfiguration.setVariables(this.configurationProperties); &#125; else if (this.configurationProperties != null) &#123; targetConfiguration.getVariables().putAll(this.configurationProperties); &#125; &#125; else if (this.configLocation != null) &#123; xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties); targetConfiguration = xmlConfigBuilder.getConfiguration(); &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\"); targetConfiguration = new Configuration(); Optional.ofNullable(this.configurationProperties).ifPresent(targetConfiguration::setVariables); &#125; Optional.ofNullable(this.objectFactory).ifPresent(targetConfiguration::setObjectFactory); Optional.ofNullable(this.objectWrapperFactory).ifPresent(targetConfiguration::setObjectWrapperFactory); Optional.ofNullable(this.vfs).ifPresent(targetConfiguration::setVfsImpl); if (hasLength(this.typeAliasesPackage)) &#123; String[] typeAliasPackageArray = tokenizeToStringArray(this.typeAliasesPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); Stream.of(typeAliasPackageArray).forEach(packageToScan -&gt; &#123; targetConfiguration.getTypeAliasRegistry().registerAliases(packageToScan, typeAliasesSuperType == null ? Object.class : typeAliasesSuperType); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for aliases\"); &#125;); &#125; if (!isEmpty(this.typeAliases)) &#123; Stream.of(this.typeAliases).forEach(typeAlias -&gt; &#123; targetConfiguration.getTypeAliasRegistry().registerAlias(typeAlias); LOGGER.debug(() -&gt; \"Registered type alias: '\" + typeAlias + \"'\"); &#125;); &#125; if (!isEmpty(this.plugins)) &#123; Stream.of(this.plugins).forEach(plugin -&gt; &#123; targetConfiguration.addInterceptor(plugin); LOGGER.debug(() -&gt; \"Registered plugin: '\" + plugin + \"'\"); &#125;); &#125; if (hasLength(this.typeHandlersPackage)) &#123; String[] typeHandlersPackageArray = tokenizeToStringArray(this.typeHandlersPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); Stream.of(typeHandlersPackageArray).forEach(packageToScan -&gt; &#123; targetConfiguration.getTypeHandlerRegistry().register(packageToScan); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for type handlers\"); &#125;); &#125; if (!isEmpty(this.typeHandlers)) &#123; Stream.of(this.typeHandlers).forEach(typeHandler -&gt; &#123; targetConfiguration.getTypeHandlerRegistry().register(typeHandler); LOGGER.debug(() -&gt; \"Registered type handler: '\" + typeHandler + \"'\"); &#125;); &#125; if (this.databaseIdProvider != null) &#123;//fix #64 set databaseId before parse mapper xmls try &#123; targetConfiguration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource)); &#125; catch (SQLException e) &#123; throw new NestedIOException(\"Failed getting a databaseId\", e); &#125; &#125; Optional.ofNullable(this.cache).ifPresent(targetConfiguration::addCache); if (xmlConfigBuilder != null) &#123; try &#123; xmlConfigBuilder.parse(); LOGGER.debug(() -&gt; \"Parsed configuration file: '\" + this.configLocation + \"'\"); &#125; catch (Exception ex) &#123; throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; targetConfiguration.setEnvironment(new Environment(this.environment, this.transactionFactory == null ? new SpringManagedTransactionFactory() : this.transactionFactory, this.dataSource)); if (!isEmpty(this.mapperLocations)) &#123; for (Resource mapperLocation : this.mapperLocations) &#123; if (mapperLocation == null) &#123; continue; &#125; try &#123; XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(), targetConfiguration, mapperLocation.toString(), targetConfiguration.getSqlFragments()); xmlMapperBuilder.parse(); &#125; catch (Exception e) &#123; throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; LOGGER.debug(() -&gt; \"Parsed mapper file: '\" + mapperLocation + \"'\"); &#125; &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'mapperLocations' was not specified or no matching resources found\"); &#125; return this.sqlSessionFactoryBuilder.build(targetConfiguration);&#125; InitializingBean12345678910111213public interface InitializingBean &#123; /** * Invoked by the containing &#123;@code BeanFactory&#125; after it has set all bean properties * and satisfied &#123;@link BeanFactoryAware&#125;, &#123;@code ApplicationContextAware&#125; etc. * &lt;p&gt;This method allows the bean instance to perform validation of its overall * configuration and final initialization when all bean properties have been set. * @throws Exception in the event of misconfiguration (such as failure to set an * essential property) or if initialization fails for any other reason */ void afterPropertiesSet() throws Exception;&#125; ApplicationListener12345678910@FunctionalInterfacepublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 12345678910/** * &#123;@inheritDoc&#125; */@Overridepublic void onApplicationEvent(ApplicationEvent event) &#123; if (failFast &amp;&amp; event instanceof ContextRefreshedEvent) &#123; // fail-fast -&gt; check all statements are completed this.sqlSessionFactory.getConfiguration().getMappedStatementNames(); &#125;&#125;","categories":[{"name":"mybatis","slug":"mybatis","permalink":"https://llllwgd.github.io/categories/mybatis/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://llllwgd.github.io/tags/mysql/"},{"name":"spring","slug":"spring","permalink":"https://llllwgd.github.io/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"https://llllwgd.github.io/tags/mybatis/"}],"keywords":[{"name":"mybatis","slug":"mybatis","permalink":"https://llllwgd.github.io/categories/mybatis/"}]},{"title":"seata启动流程","slug":"start_code","date":"2020-06-26T00:17:23.477Z","updated":"2020-07-12T03:08:20.505Z","comments":true,"path":"2020/06/26/start_code/","link":"","permalink":"https://llllwgd.github.io/2020/06/26/start_code/","excerpt":"","text":"seata 启动流程源码开启分布式事务的注解@GlobalTransactional 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface GlobalTransactional &#123; /** * Global transaction timeoutMills in MILLISECONDS. * * @return timeoutMills in MILLISECONDS. */ int timeoutMills() default TransactionInfo.DEFAULT_TIME_OUT; /** * Given name of the global transaction instance. * * @return Given name. */ String name() default \"\"; /** * roll back for the Class * @return */ Class&lt;? extends Throwable&gt;[] rollbackFor() default &#123;&#125;; /** * roll back for the class name * @return */ String[] rollbackForClassName() default &#123;&#125;; /** * not roll back for the Class * @return */ Class&lt;? extends Throwable&gt;[] noRollbackFor() default &#123;&#125;; /** * not roll back for the class name * @return */ String[] noRollbackForClassName() default &#123;&#125;; /** * the propagation of the global transaction * @return */ Propagation propagation() default Propagation.REQUIRED;&#125; 扫描注解的实现类1GlobalTransactionScanner springboot启动类123456org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.alibaba.cloud.seata.rest.SeataRestTemplateAutoConfiguration,\\com.alibaba.cloud.seata.web.SeataHandlerInterceptorConfiguration,\\com.alibaba.cloud.seata.GlobalTransactionAutoConfiguration,\\com.alibaba.cloud.seata.feign.SeataFeignClientAutoConfiguration,\\com.alibaba.cloud.seata.feign.hystrix.SeataHystrixAutoConfiguration 123456789101112131415161718192021222324252627282930@Configuration@EnableConfigurationProperties(SeataProperties.class)public class GlobalTransactionAutoConfiguration &#123; private final ApplicationContext applicationContext; private final SeataProperties seataProperties; public GlobalTransactionAutoConfiguration(ApplicationContext applicationContext, SeataProperties seataProperties) &#123; this.applicationContext = applicationContext; this.seataProperties = seataProperties; &#125; @Bean public GlobalTransactionScanner globalTransactionScanner() &#123; String applicationName = applicationContext.getEnvironment() .getProperty(\"spring.application.name\"); String txServiceGroup = seataProperties.getTxServiceGroup(); if (StringUtils.isEmpty(txServiceGroup)) &#123; txServiceGroup = applicationName + \"-fescar-service-group\"; seataProperties.setTxServiceGroup(txServiceGroup); &#125; return new GlobalTransactionScanner(applicationName, txServiceGroup); &#125;&#125; 接口和父类InitializingBean12345public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 在对象设置完属性之后执行 12345678910@Overridepublic void afterPropertiesSet() &#123; if (disableGlobalTransaction) &#123; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Global transaction is disabled.\"); &#125; return; &#125; initClient();&#125; 123456789101112131415161718192021222324private void initClient() &#123; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Initializing Global Transaction Clients ... \"); &#125; if (StringUtils.isNullOrEmpty(applicationId) || StringUtils.isNullOrEmpty(txServiceGroup)) &#123; throw new IllegalArgumentException(String.format(\"applicationId: %s, txServiceGroup: %s\", applicationId, txServiceGroup)); &#125; //init TM TMClient.init(applicationId, txServiceGroup); if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Transaction Manager Client is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]\", applicationId, txServiceGroup); &#125; //init RM RMClient.init(applicationId, txServiceGroup); if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Resource Manager is initialized. applicationId[&#123;&#125;] txServiceGroup[&#123;&#125;]\", applicationId, txServiceGroup); &#125; if (LOGGER.isInfoEnabled()) &#123; LOGGER.info(\"Global Transaction Clients are initialized. \"); &#125; registerSpringShutdownHook();&#125; ApplicationContextAware 获取spring容器 12345public interface ApplicationContextAware extends Aware &#123; void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125; 12345@Overridepublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; this.setBeanFactory(applicationContext);&#125; DisposableBean 对象销毁的时候执行 12345public interface DisposableBean &#123; void destroy() throws Exception;&#125; 1234@Overridepublic void destroy() &#123; ShutdownHook.getInstance().destroyAll();&#125; 123456789101112public void destroyAll() &#123; if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"destoryAll starting\"); &#125; if (!destroyed.compareAndSet(false, true) &amp;&amp; CollectionUtils.isEmpty(disposables)) &#123; return; &#125; for (Disposable disposable : disposables) &#123; disposable.destroy(); &#125;&#125; 123456@Overridepublic void destroy() &#123; super.destroy(); initialized.getAndSet(false); instance = null;&#125; AbstractAutoProxyCreator12345678910111213141516171819202122232425protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Overrideprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; //是否开启全局事物 if (disableGlobalTransaction) &#123; return bean; &#125; try &#123; synchronized (PROXYED_SET) &#123; if (PROXYED_SET.contains(beanName)) &#123; return bean; &#125; interceptor = null; //check TCC proxy if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) &#123; //TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC interceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName)); &#125; else &#123; Class&lt;?&gt; serviceInterface = SpringProxyUtils.findTargetClass(bean); Class&lt;?&gt;[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean); if (!existsAnnotation(new Class[]&#123;serviceInterface&#125;) &amp;&amp; !existsAnnotation(interfacesIfJdk)) &#123; return bean; &#125; if (interceptor == null) &#123; interceptor = new GlobalTransactionalInterceptor(failureHandlerHook); ConfigurationFactory.getInstance().addConfigListener(ConfigurationKeys.DISABLE_GLOBAL_TRANSACTION, (ConfigurationChangeListener) interceptor); &#125; &#125; LOGGER.info(\"Bean[&#123;&#125;] with name [&#123;&#125;] would use interceptor [&#123;&#125;]\", bean.getClass().getName(), beanName, interceptor.getClass().getName()); if (!AopUtils.isAopProxy(bean)) &#123; bean = super.wrapIfNecessary(bean, beanName, cacheKey); &#125; else &#123; AdvisedSupport advised = SpringProxyUtils.getAdvisedSupport(bean); Advisor[] advisor = buildAdvisors(beanName, getAdvicesAndAdvisorsForBean(null, null, null)); for (Advisor avr : advisor) &#123; advised.addAdvisor(0, avr); &#125; &#125; PROXYED_SET.add(beanName); return bean; &#125; &#125; catch (Exception exx) &#123; throw new RuntimeException(exx); &#125;&#125; 12345678910111213141516171819202122232425protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; if (StringUtils.hasLength(beanName) &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 12345@Overrideprotected Object[] getAdvicesAndAdvisorsForBean(Class beanClass, String beanName, TargetSource customTargetSource) throws BeansException &#123; return new Object[]&#123;interceptor&#125;;&#125; 12345678910111213141516@FunctionalInterfacepublic interface MethodInterceptor extends Interceptor &#123; /** * Implement this method to perform extra treatments before and * after the invocation. Polite implementations would certainly * like to invoke &#123;@link Joinpoint#proceed()&#125;. * @param invocation the method invocation joinpoint * @return the result of the call to &#123;@link Joinpoint#proceed()&#125;; * might be intercepted by the interceptor * @throws Throwable if the interceptors or the target object * throws an exception */ Object invoke(MethodInvocation invocation) throws Throwable;&#125; 123456@FunctionalInterfacepublic interface MethodInterceptor extends Interceptor &#123; Object invoke(MethodInvocation invocation) throws Throwable;&#125; 1234567891011121314151617@Overridepublic Object invoke(final MethodInvocation methodInvocation) throws Throwable &#123; Class&lt;?&gt; targetClass = methodInvocation.getThis() != null ? AopUtils.getTargetClass(methodInvocation.getThis()) : null; Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass); final Method method = BridgeMethodResolver.findBridgedMethod(specificMethod); final GlobalTransactional globalTransactionalAnnotation = getAnnotation(method, GlobalTransactional.class); final GlobalLock globalLockAnnotation = getAnnotation(method, GlobalLock.class); if (!disable &amp;&amp; globalTransactionalAnnotation != null) &#123; return handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation); &#125; else if (!disable &amp;&amp; globalLockAnnotation != null) &#123; return handleGlobalLock(methodInvocation); &#125; else &#123; return methodInvocation.proceed(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private Object handleGlobalTransaction(final MethodInvocation methodInvocation, final GlobalTransactional globalTrxAnno) throws Throwable &#123; try &#123; return transactionalTemplate.execute(new TransactionalExecutor() &#123; @Override public Object execute() throws Throwable &#123; return methodInvocation.proceed(); &#125; public String name() &#123; String name = globalTrxAnno.name(); if (!StringUtils.isNullOrEmpty(name)) &#123; return name; &#125; return formatMethod(methodInvocation.getMethod()); &#125; @Override public TransactionInfo getTransactionInfo() &#123; TransactionInfo transactionInfo = new TransactionInfo(); transactionInfo.setTimeOut(globalTrxAnno.timeoutMills()); transactionInfo.setName(name()); transactionInfo.setPropagation(globalTrxAnno.propagation()); Set&lt;RollbackRule&gt; rollbackRules = new LinkedHashSet&lt;&gt;(); for (Class&lt;?&gt; rbRule : globalTrxAnno.rollbackFor()) &#123; rollbackRules.add(new RollbackRule(rbRule)); &#125; for (String rbRule : globalTrxAnno.rollbackForClassName()) &#123; rollbackRules.add(new RollbackRule(rbRule)); &#125; for (Class&lt;?&gt; rbRule : globalTrxAnno.noRollbackFor()) &#123; rollbackRules.add(new NoRollbackRule(rbRule)); &#125; for (String rbRule : globalTrxAnno.noRollbackForClassName()) &#123; rollbackRules.add(new NoRollbackRule(rbRule)); &#125; transactionInfo.setRollbackRules(rollbackRules); return transactionInfo; &#125; &#125;); &#125; catch (TransactionalExecutor.ExecutionException e) &#123; TransactionalExecutor.Code code = e.getCode(); switch (code) &#123; case RollbackDone: throw e.getOriginalException(); case BeginFailure: failureHandler.onBeginFailure(e.getTransaction(), e.getCause()); throw e.getCause(); case CommitFailure: failureHandler.onCommitFailure(e.getTransaction(), e.getCause()); throw e.getCause(); case RollbackFailure: failureHandler.onRollbackFailure(e.getTransaction(), e.getCause()); throw e.getCause(); case RollbackRetrying: failureHandler.onRollbackRetrying(e.getTransaction(), e.getCause()); throw e.getCause(); default: throw new ShouldNeverHappenException(String.format(\"Unknown TransactionalExecutor.Code: %s\", code)); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public Object execute(TransactionalExecutor business) throws Throwable &#123; // 1 get transactionInfo TransactionInfo txInfo = business.getTransactionInfo(); if (txInfo == null) &#123; throw new ShouldNeverHappenException(\"transactionInfo does not exist\"); &#125; // 1.1 get or create a transaction GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate(); // 1.2 Handle the Transaction propatation and the branchType Propagation propagation = txInfo.getPropagation(); SuspendedResourcesHolder suspendedResourcesHolder = null; try &#123; switch (propagation) &#123; case NOT_SUPPORTED: suspendedResourcesHolder = tx.suspend(true); return business.execute(); case REQUIRES_NEW: suspendedResourcesHolder = tx.suspend(true); break; case SUPPORTS: if (!existingTransaction()) &#123; return business.execute(); &#125; break; case REQUIRED: break; case NEVER: if (existingTransaction()) &#123; throw new TransactionException( String.format(\"Existing transaction found for transaction marked with propagation 'never',xid = %s\" ,RootContext.getXID())); &#125; else &#123; return business.execute(); &#125; case MANDATORY: if (!existingTransaction()) &#123; throw new TransactionException(\"No existing transaction found for transaction marked with propagation 'mandatory'\"); &#125; break; default: throw new TransactionException(\"Not Supported Propagation:\" + propagation); &#125; try &#123; // 2. begin transaction beginTransaction(txInfo, tx); Object rs = null; try &#123; // Do Your Business rs = business.execute(); &#125; catch (Throwable ex) &#123; // 3.the needed business exception to rollback. completeTransactionAfterThrowing(txInfo, tx, ex); throw ex; &#125; // 4. everything is fine, commit. commitTransaction(tx); return rs; &#125; finally &#123; //5. clear triggerAfterCompletion(); cleanUp(); &#125; &#125; finally &#123; tx.resume(suspendedResourcesHolder); &#125;&#125;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://llllwgd.github.io/categories/mysql/"}],"tags":[{"name":"seata","slug":"seata","permalink":"https://llllwgd.github.io/tags/seata/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://llllwgd.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"mysql","slug":"mysql","permalink":"https://llllwgd.github.io/tags/mysql/"}],"keywords":[{"name":"mysql","slug":"mysql","permalink":"https://llllwgd.github.io/categories/mysql/"}]},{"title":"seata-demo","slug":"seata-demo","date":"2020-06-25T07:33:32.522Z","updated":"2020-07-12T03:02:24.600Z","comments":true,"path":"2020/06/25/seata-demo/","link":"","permalink":"https://llllwgd.github.io/2020/06/25/seata-demo/","excerpt":"","text":"seata demogit地址https://github.com/llllwgd/database.git sqltodo 测试地址 http://localhost:8180/order/create?userId=1&amp;productId=1&amp;count=10&amp;money=100","categories":[{"name":"数据库","slug":"数据库","permalink":"https://llllwgd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"seata","slug":"seata","permalink":"https://llllwgd.github.io/tags/seata/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://llllwgd.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"mysql","slug":"mysql","permalink":"https://llllwgd.github.io/tags/mysql/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"https://llllwgd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"info","slug":"info","date":"2020-06-25T06:55:41.564Z","updated":"2020-06-25T07:16:18.314Z","comments":true,"path":"2020/06/25/info/","link":"","permalink":"https://llllwgd.github.io/2020/06/25/info/","excerpt":"","text":"seata 简介Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。支持的模式 AT模式 TCC模式 saga模式 AT模式 一阶段prepare行为:在本地事务中,一并提交业务数据的更新和相应回滚日志 二阶段commit行为:成功,自动批量删除回滚日志 二阶段rollback行为:通过回滚日志,自动生成补偿操作,完成数据回滚 TCC模式 一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。 二阶段 commit 行为：调用 自定义 的 commit 逻辑。 二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。 Saga模式 todo : 未能理解","categories":[],"tags":[],"keywords":[]},{"title":"xa协议","slug":"xa","date":"2020-06-23T14:12:32.623Z","updated":"2020-07-12T03:07:18.608Z","comments":true,"path":"2020/06/23/xa/","link":"","permalink":"https://llllwgd.github.io/2020/06/23/xa/","excerpt":"","text":"xa协议简介 资源管理器与事务管理器之间通信的标准接口 通过两阶段提交实现分布式事务， demo123456789101112131415xa start &#39;xatest&#39;;insert into user value (&#39;11&#39;);xa end &#39;xatest&#39;;&#x2F;&#x2F;询问阶段xa prepare &#39;xatest&#39;;xa commit &#39;xatest&#39;;xa rollback &#39;xatest&#39;;&#x2F;&#x2F;查看已经prepare的事务xa recover;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://llllwgd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://llllwgd.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"https://llllwgd.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"命令模式","slug":"command","date":"2020-06-14T08:01:30.433Z","updated":"2020-07-12T05:08:28.921Z","comments":true,"path":"2020/06/14/command/","link":"","permalink":"https://llllwgd.github.io/2020/06/14/command/","excerpt":"","text":"命令模式使用场景 行为的请求者与行为的实现着需要松耦合 将多个行为通过宏宏命令进行组装 demo命令接口1234567public interface Command &#123; /** * 执行命令 */ void execute();&#125; 命令实现类12345678910111213public class PlayCommand implements Command &#123; private Executor executor; public PlayCommand(Executor executor) &#123; this.executor = executor; &#125; @Override public void execute() &#123; executor.play(); &#125;&#125; 命令的执行者123456public class Executor &#123; public void play() &#123; System.out.println(\"正在播放\"); &#125;&#125; 命令的调用者12345678910111213public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void doSomething() &#123; command.execute(); &#125;&#125; 测试1234567891011public class CommandTest &#123; @Test public void test() &#123; Executor executor = new Executor(); Command command = new PlayCommand(executor); Invoker invoker = new Invoker(command); invoker.doSomething(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://llllwgd.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}]},{"title":"redsi持久化","slug":"redis持久化","date":"2020-06-06T02:13:39.613Z","updated":"2020-07-12T05:34:46.700Z","comments":true,"path":"2020/06/06/redis持久化/","link":"","permalink":"https://llllwgd.github.io/2020/06/06/redis%E6%8C%81%E4%B9%85%E5%8C%96/","excerpt":"","text":"redis持久化持久化的方式 rdb aof rdm工作方式Redis 调用forks. 同时拥有父进程和子进程。子进程将数据集写入到一个临时 RDB 文件中。当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 优点 备份文件比较小 支持多种备份模式同时存在， 比如每5分钟备份前30分钟，每1一天备份一个月的 恢复速度比aof快 缺点 丢失最后一次备份之后的数据 数据量大的时候备份影响系统性能 aofRedis 调用forks. 同时拥有父进程和子进程。子进程将数据集写入到一个临时 RDB 文件中。当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 优点 故障时丢失的数据较少 对文件进行重写 缺点 备份文件大 恢复速度慢","categories":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}]},{"title":"redis命令","slug":"redis命令","date":"2020-06-06T00:52:13.803Z","updated":"2020-07-12T03:10:39.064Z","comments":true,"path":"2020/06/06/redis命令/","link":"","permalink":"https://llllwgd.github.io/2020/06/06/redis%E5%91%BD%E4%BB%A4/","excerpt":"","text":"redis命令append存在key的话，向字符串追加，不存在则创建应用：通过每次追加一定长度的字符串，需要的时候通过getrange命令获取 bitcount统计字符串被设置为1的bit数.应用：用户登陆统计 eval执行lua脚本EVAL script numkeys key [key …] arg [arg …]注意：脚本中执行redis命令，一定要将key设置为参数1。redis命令执行的时候需要分析操作哪些key2。如果是集群环境 ，有key的话可以正确的交由某个节点处理","categories":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}]},{"title":"redis的缺点","slug":"redis的缺点","date":"2020-06-06T00:42:22.058Z","updated":"2020-07-12T03:10:08.394Z","comments":true,"path":"2020/06/06/redis的缺点/","link":"","permalink":"https://llllwgd.github.io/2020/06/06/redis%E7%9A%84%E7%BC%BA%E7%82%B9/","excerpt":"","text":"redis的缺点 持久化影响性能 占用较多内存资源","categories":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}]},{"title":"redis的使用场景","slug":"redis使用场景","date":"2020-06-05T23:56:39.440Z","updated":"2020-07-12T03:11:14.677Z","comments":true,"path":"2020/06/06/redis使用场景/","link":"","permalink":"https://llllwgd.github.io/2020/06/06/redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"redis的使用场景 高性能适合做缓存 对字典表进行缓存（对字典表的操作同步到redis） 缓存数据，访问数据时先读取redis中的数据，没有的话再去读取mysql（避免缓存击穿，而且数据实时性不高， 因为要先存入mysql，再同步到redis） 数据结构丰富 string k-v形式，适合存储短信验证码，配置信息等 hash 用于对象信息的存储 list 有序的队列，适用于消息对接 set 无序的队列，适用于求交集，并集等操作 Sorted set set的加强版，增加了score属性， 可以根据score进行排序 单线程可以用作分布式锁 自动过期提高开发效率 分布式和持久化应对海量数据和高并发 分布式会话 将redis作为tomcat的session内存","categories":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/tags/redis/"}],"keywords":[{"name":"redis","slug":"redis","permalink":"https://llllwgd.github.io/categories/redis/"}]},{"title":"springboot docker","slug":"springboot_docker_package","date":"2020-05-02T15:00:43.260Z","updated":"2020-07-12T03:14:47.026Z","comments":true,"path":"2020/05/02/springboot_docker_package/","link":"","permalink":"https://llllwgd.github.io/2020/05/02/springboot_docker_package/","excerpt":"","text":"springboot项目使用docker部署docker部署的优势 隔离将Docker可以将我们的应用程序打包封装到一个容器中，该容器包含了应用程序的代码、运行环境、依赖库、配置文件等必需的资源。容器之间达到进程级别的隔离，在容器中的操作，不会影响道宿主机和其他容器，这样就不会出现应用之间相互影响的情形！ 可移植性可以实现开发、测试和生产环境的统一化和标准化。镜像作为标准的交付件，可在开发、测试和生产环境上以容器来运行，最终实现三套环境上的应用以及运行所依赖内容的完全一致。 轻量和高效和虚拟机相比，容器仅需要封装应用和应用需要的依赖文件，实现轻量的应用运行环境，且拥有比虚拟机更高的硬件资源利用率。在微服务架构中，有些服务负载压力大，需要以集群部署，可能要部署几十台机器上，对于某些中小型公司来说，使用虚拟机，代价太大。如果用容器，同样的物理机则能支持上千个容器，对中小型公司来说，省钱！docker部署的缺点 docker表面上很方便，其实工具链之间的衔接十分糟糕。docker将linux的namespace做了深层次的封装，使用户上手的难度非常低，部署到生产环境也很容易。但这仅限于小型项目，比如你的一个nodejs+mongodb或者php+mysql的架构方式。如果是稍微复杂一些的项目，依赖关系非常多的话，你会发现，docker会出现各种神奇的bug。比如docker-compose之间的依赖不会等待被依赖者加载完毕，挂载volume有时会无法在entrypoint或command中执行命令，必须要用COPY…诸如此类，原本不需要如此复杂的部署，如今却变得复杂和难以维护。在进行多机部署的时候，跟着官方文档走都不能成功，上stackoverflow和github上查了半天也查不到任何解决办法，是经常发生的事情。当然用多了之后会习惯docker的不完美，但也会让你思考，这个项目一定需要使用docker吗？ docker的确降低了运维难度，但是加大了运营成本。在我看来，docker最大的一个缺点是，十分吃硬盘。docker封装的namespace，但是并没有对文件进行进一步的管理，只是粗暴的将文件到处复制粘贴。当服务器上开了数百个容器后发现1TB的硬盘被吃掉了一半时，我的内心里只有两个字：绝望。这意味着需要不停增加服务器资源才能维持系统的运行，如果不采用docker部署的方式，可能并不需要如此大的磁盘空间。除了磁盘空间的占用外，作为一名中国用户，时区、墙等都是问题，当然这些问题都是可以解决的，但是也很花费时间。我并不是在指责docker的不好，正相反，我觉得docker是个非常酷的工具。使用docker后，在我更新半年前写的爬虫时，完全不用担心该怎么从新部署，还是那条熟悉的命令即可完成，减轻了很多记忆上的压力。demo修改pom.xml 1234567891011121314&lt;properties&gt; &lt;docker.image.prefix&gt;llllwgd&lt;&#x2F;docker.image.prefix&gt; &lt;&#x2F;properties&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;&#x2F;artifactId&gt; &lt;version&gt;1.3.6&lt;&#x2F;version&gt; &lt;configuration&gt; &lt;repository&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target&#x2F;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;JAR_FILE&gt; &lt;&#x2F;buildArgs&gt; &lt;&#x2F;configuration&gt; &lt;&#x2F;plugin&gt; 编写Dockerfile,默认位置在项目的根目录下12345FROM openjdk:8-jdk-alpineVOLUME &#x2F;tmpARG JAR_FILECOPY $&#123;JAR_FILE&#125; app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;] 打包命令12mvn install dockerfile:build -Dmaven.test.skip&#x3D;true dependency:copy-dependencies -DoutputDirectory&#x3D;libdocker image prune -f 查看docker镜像1docker images 启动项目1docker run -it -d -p 8080:8080 --name docker-study -m 215M 镜像id 进入容器1docker exec -ti 容器名称 &#x2F;bin&#x2F;sh 查看日志1docker logs -f 容器名称 给镜像打标签1docker tag 镜像名 用户名&#x2F;标签名:版本 推动到远程仓库1docker push 标签名:版本","categories":[{"name":"docker","slug":"docker","permalink":"https://llllwgd.github.io/categories/docker/"}],"tags":[{"name":"sprngboot","slug":"sprngboot","permalink":"https://llllwgd.github.io/tags/sprngboot/"},{"name":"docker","slug":"docker","permalink":"https://llllwgd.github.io/tags/docker/"}],"keywords":[{"name":"docker","slug":"docker","permalink":"https://llllwgd.github.io/categories/docker/"}]},{"title":"java动态编译","slug":"compile","date":"2020-04-25T07:33:23.015Z","updated":"2020-07-12T03:02:06.571Z","comments":true,"path":"2020/04/25/compile/","link":"","permalink":"https://llllwgd.github.io/2020/04/25/compile/","excerpt":"","text":"java动态编译目的通过动态编译，避免每次更改代码都需要重启 目前存在的问题 多次编译引起的内存不足的问题（使用静态工厂模式，讲class对象缓存起来，不必每次都去加载，从工厂中获取） 脚本如何维护 脚本的安全性demo自定义类加载器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.llllwgd.springoboot.demo.compile;import java.io.*;/** * Created with IntelliJ IDEA. * Description: 自定义类加载器 * * @author : wangguodong * Date: 2020-04-21 * Time: 22:56 */public class MyClassLoad extends ClassLoader &#123; /** * class文件路径 */ private String rootPath; public MyClassLoad(String rootPath) &#123; this.rootPath = rootPath; &#125; /** * 根据name来寻找该类 */ @Override protected Class&lt;?&gt; findClass(String name) &#123; Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; c = findMyClass(name); &#125; return c; &#125; /** * 加载该类 * * @param name * @return */ private Class&lt;?&gt; findMyClass(String name) &#123; try &#123; byte[] bytes = getData(name); // 调用父类方法，生成具体类 assert bytes != null; return this.defineClass(null, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; private byte[] getData(String className) &#123; String path = rootPath + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; InputStream is = null; try &#123; is = new FileInputStream(path); ByteArrayOutputStream stream = new ByteArrayOutputStream(); byte[] buffer = new byte[2048]; int num = 0; while ((num = is.read(buffer)) != -1) &#123; stream.write(buffer, 0, num); &#125; return stream.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125;&#125; 编译工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.llllwgd.springoboot.demo.compile;import javax.tools.*;import java.io.File;import java.net.URI;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Created with IntelliJ IDEA. * Description: 编译工具类 * * @author : wangguodong * Date: 2020-04-18 * Time: 16:53 */public class CompileUtil &#123; /** * 指定生成的class文件的路径 */ public static final String ROOT_PATH = \"/Users/wangguodong/IdeaProjects/llllwgd/demo/shell/\"; public static final String PACKAGE_PATTERN = \"package\\\\s+\\\\S+\\\\s*;\"; public static final String CLASS_PATTERN = \"class\\\\s+\\\\S+\\\\s+\\\\&#123;\"; /** * 获取class对象 * * @param sourceCode 辅助类代码 * @param mainCode 主类代码 * @param planCode 方案编码 * @return */ public Class compile(List&lt;String&gt; sourceCode, String mainCode, String planCode) throws Exception &#123; //创建存放class文件的文件夹 File file = new File(ROOT_PATH + planCode); if (!file.exists()) &#123; file.mkdirs(); &#125; MyClassLoad myClassLoad = new MyClassLoad(ROOT_PATH + planCode); JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager standardFileManager = javaCompiler.getStandardFileManager(null, null, null); //创建java文件对象 //加载工具类 List&lt;JavaFileObject&gt; javas = new ArrayList&lt;&gt;(); List&lt;String&gt; fileName = new ArrayList&lt;&gt;(); sourceCode.add(mainCode); for (String code : sourceCode) &#123; String className = getFullClassName(code); StringJavaObject stringJavaObject = new StringJavaObject(className, code); javas.add(stringJavaObject); fileName.add(className); &#125; //加载主类 List&lt;String&gt; optionsList = new ArrayList&lt;&gt;(Arrays.asList(\"-d\", ROOT_PATH + planCode)); // 执行编译任务 JavaCompiler.CompilationTask task = javaCompiler.getTask(null, standardFileManager, null, optionsList, null, javas); task.call(); standardFileManager.close(); for (String name : fileName) &#123; myClassLoad.loadClass(name); &#125; return myClassLoad.loadClass(getFullClassName(mainCode)); &#125; /** * 获取java文件中的全类名 * * @param sourceCode 源码 * @return */ public static String getFullClassName(String sourceCode) &#123; String className = \"\"; Pattern pattern = Pattern.compile(PACKAGE_PATTERN); Matcher matcher = pattern.matcher(sourceCode); if (matcher.find()) &#123; className = matcher.group().replaceFirst(\"package\", \"\").replace(\";\", \"\").trim() + \".\"; &#125; pattern = Pattern.compile(CLASS_PATTERN); matcher = pattern.matcher(sourceCode); if (matcher.find()) &#123; className += matcher.group().replaceFirst(\"class\", \"\").replace(\"&#123;\", \"\").trim(); &#125; return className; &#125; /** * java文件对象 */ static class StringJavaObject extends SimpleJavaFileObject &#123; /** * java代码 */ private String content; /** * @param javaFileName 文件名 ， 不带.java * @param content java源码 */ public StringJavaObject(String javaFileName, String content) &#123; super(createStringJavaObjectUri(javaFileName), Kind.SOURCE); this.content = content; &#125; /** * 创建资源 * * @param name * @return */ private static URI createStringJavaObjectUri(String name) &#123; return URI.create(\"String:///\" + name + Kind.SOURCE.extension); &#125; /** * 获取源代码 * * @param ignoreEncodingErrors * @return */ @Override public CharSequence getCharContent(boolean ignoreEncodingErrors) &#123; return content; &#125; &#125;&#125; 返回","categories":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://llllwgd.github.io/tags/%E7%BC%96%E8%AF%91/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://llllwgd.github.io/categories/java/"}]}]}